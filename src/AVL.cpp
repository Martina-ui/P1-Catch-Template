#include <atomic>
#include "AVL.h"
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

static bool remove_flag = false;

void AVLTree::check_commands(string commands) {
    if (commands == "") {
        throw invalid_argument("Error: No command provided");
    }

    istringstream iss(commands);
    vector<string> commandList;
    string command;

    while (iss >> command) {
        commandList.push_back(command);
    }

    int size = commandList.size();
    string cmd = commandList[0];

    if (cmd == "insert") {
        // if (size < 3) {
        //     throw invalid_argument("Error: Invalid number of arguments for insert");
        // }
        string name = commandList[1];
        for (int i = 2; i < size - 1; ++i) {
            name += " " + commandList[i];
        }
        string ufid = commandList[size - 1];
        if (!name.empty() && name.front() == '"' && name.back() == '"') {
            name = name.substr(1, name.length() - 2); 
        }
        if (name.empty() || ufid.empty()) {
            throw invalid_argument("Error: Name and UFID cannot be empty");
        }
        if (!all_of(name.begin(), name.end(), [](char c){ return isalpha(c) || c == ' '; })) { //this syntax was generated by codespace autocomplete
            throw invalid_argument("Error: Name must contain only alphabetic characters and spaces");
        }
        if (ufid.length() != 8 || !all_of(ufid.begin(), ufid.end(), ::isdigit)) { //this syntax was generated by codespace autocomplete
            throw invalid_argument("Error: UFID must be an 8-digit number");
        }
        int ufid_int = stoi(ufid);
        insert(name, ufid_int);

    } else if (cmd == "remove") {
        if (size != 2) {
            throw invalid_argument("Error: Invalid number of arguments for remove");
        }
        int ufid = stoi(commandList[1]);
        remove(this->get_root(), ufid);

    } else if (cmd == "search") {
        if (size < 2) {
            throw invalid_argument("Error: Invalid number of arguments for search");
        }
        if (all_of(commandList[1].begin(), commandList[1].end(), ::isdigit)) {
            int ufid = stoi(commandList[1]);
            search_id(ufid);
            return;
        } 
        string name = commandList[1];
        if (!name.empty() && name.front() == '"' && name.back() == '"') {
            name = name.substr(1, name.length() - 2); 
        }
        search_name(name);

    } else if (cmd == "printInorder") {
        if (size != 1) {
            throw invalid_argument("Error: Invalid number of arguments for printInorder");
        }
        print_inorder(this->root);

    } else if (cmd == "printPreorder") {
        if (size != 1) {
            throw invalid_argument("Error: Invalid number of arguments for printPreorder");
        }
        print_preorder(this->root);

    } else if (cmd == "printPostorder") {
        if (size != 1) {
            throw invalid_argument("Error: Invalid number of arguments for printPostorder");
        }
        print_postorder(this->root);

    } else if (cmd == "printLevelCount") {
        if (size != 1) {
            throw invalid_argument("Error: Invalid number of arguments for printLevelCount");
        }
        print_level_count();

    } else if (cmd == "removeInorder") {
        if (size != 2) {
            throw invalid_argument("Error: Invalid number of arguments for removeInorder");
        }
        int nth_node;
        try {
            nth_node = stoi(commandList[1]);
        } catch (const exception& e) {
            throw invalid_argument("Error: Argument for removeInorder must be an integer");
        }
        remove_inorder(nth_node);

    } else {
        throw invalid_argument("Error: Unknown command");
    }
}

void AVLTree::insert(string name, int ufid) { //117-123 was taken from project 1 video walkthrough
    Node* temp = this->root;
    this->root = insertHelper(this->root, name, ufid);
    if (this->root != nullptr) {
        cout << "successful" << endl;
    } else {
        this->root = temp;
        cout << "unsuccessful" << endl;
    }
}

Node* AVLTree::insertHelper(Node* node, string name, int ufid) { //lines 128-142 was taken from class slides on Balanced BSTs slide on AVL tree: insert
    if (node == nullptr) {
        return new Node(name, ufid);
    }
    if (ufid < node->ufid) {
        node->left = insertHelper(node->left, name, ufid);
    } else if (ufid > node->ufid) {
        node->right = insertHelper(node->right, name, ufid);
    } else if (node->name == name && node->ufid == ufid) {
        return node;
    } 
    if (node != nullptr) {
        node = balance_tree(node, ufid);
    }
    return node;
}

Node* AVLTree::balance_tree(Node* node, int ufid) {
    //for lines 145-183 i used syntax from https://www.geeksforgeeks.org/dsa/insertion-in-an-avl-tree/ and the class slides for Balanced BSTs talking about rotations
    node->height = 1 + max(get_height(node->left), get_height(node->right)); 
    int balance = get_balance(node);

    //left left rotation = right rotation
    if (balance > 1 && ufid < node->left->ufid) {
        Node* new_root = node->left;
        node->left = new_root->right;
        new_root->right = node;
        node->height = 1 + max(get_height(node->left), get_height(node->right));
        new_root->height = 1 + max(get_height(new_root->left), get_height(new_root->right));
        return new_root;
    }
    //right right rotation = left rotation
    if (balance < -1 && ufid > node->right->ufid) {
        Node* new_root = node->right;
        node->right = new_root->left;
        new_root->left = node;
        node->height = 1 + max(get_height(node->left), get_height(node->right));
        new_root->height = 1 + max(get_height(new_root->left), get_height(new_root->right));
        return new_root;
    }
    //left right rotation: left child left, then right
    if (balance > 1 && ufid > node->left->ufid) {
        Node* child_left = node->left;
        Node* left_right = child_left->right;
        child_left->right = left_right->left;
        left_right->left = child_left;
        child_left->height = 1 + max(get_height(child_left->left), get_height(child_left->right));
        left_right->height = 1 + max(get_height(left_right->left), get_height(left_right->right));
        node->left = left_right;

        Node* new_root = node->left;
        node->left = new_root->right;
        new_root->right = node;
        node->height = 1 + max(get_height(node->left), get_height(node->right));
        new_root->height = 1 + max(get_height(new_root->left), get_height(new_root->right));
        return new_root;
    }

    //right left rotation: right child right, then left
    if(balance < -1 && ufid < node->right->ufid) {
        Node* child_right = node->right;
        Node* right_left = child_right->left;
        child_right->left = right_left->right;
        right_left->right = child_right;
        child_right->height = 1 + max(get_height(child_right->left), get_height(child_right->right));
        right_left->height = 1 + max(get_height(right_left->left), get_height(right_left->right));
        node->right = right_left;

        Node* new_root = node->right;
        node->right = new_root->left;
        new_root->left = node;
        node->height = 1 + max(get_height(node->left), get_height(node->right));
        new_root->height = 1 + max(get_height(new_root->left), get_height(new_root->right));
        return new_root;
    }
    return node;
}

Node* AVLTree::remove(Node* node, int ufid) { 
    if (node == nullptr) {
        if (!remove_flag) cout << "unsuccessful" << endl;
        return node;
    }

    if (ufid < node->ufid) {
        node->left = remove(node->left, ufid); //syntax from project 1 ppt slides on BST remove
    } else if (ufid > node->ufid) {
        node->right = remove(node->right, ufid);
    } else if (node->ufid == ufid) {
        if (node->left == nullptr && node->right == nullptr) {
            delete node;
            cout << "successful" << endl;
            return nullptr;
        }
        if (node->left == nullptr) {
            Node* temp = node->right;
            delete node;
            cout << "successful" << endl;
            return temp;
        }
        if (node->right == nullptr) {
            Node* temp = node->left;
            delete node;
            cout << "successful" << endl;
            return temp;
        }
        if (node->left != nullptr && node->right != nullptr) {
            Node* temp = node->right;
            while (temp->left != nullptr) {
                temp = temp->left;
            }
            node->name = temp->name;
            node->ufid = temp->ufid;
            node->right = remove(node->right, temp->ufid);
        }
        if (node != nullptr) {
            node = balance_tree(node, ufid);
        }
    }
    return node;
}

void AVLTree::search_id(int ufid) {
    Node* current = this->root;
    while (current != nullptr) {
        if (ufid == current->ufid) {
            cout << current->name << endl;
            return;
        } else if (ufid < current->ufid) {
            current = current->left;
        } else {
            current = current->right;
        }
    }
    cout << "unsuccessful" << endl;
}

void AVLTree::search_name(string name) {
    Node* current = this->root;
    if (current == nullptr) {
        cout << "unsuccessful" << endl;
        return;
    }
    traverse_subtree(current->left, name);
    traverse_subtree(current->right, name);
}

void AVLTree::traverse_subtree(Node* node, string name) {
    if (node == nullptr) return;
    traverse_subtree(node->left, name);
    if (name == node->name) {
        cout << node->ufid << endl;
    }
    traverse_subtree(node->right, name);
}

void AVLTree::print_inorder(Node* node) { 
    if (node == nullptr) { 
        cout << endl;
        return;
    }
    print_inorder(node->left);
    cout << node->name << ", ";
    print_inorder(node->right);
}

void AVLTree::print_preorder(Node* node) {
    if (node == nullptr) {
        cout << endl;
        return;
    }
    cout << node->name << ", ";
    print_preorder(node->left);
    print_preorder(node->right);
}

void AVLTree::print_postorder(Node* node) {
    if (node == nullptr) {
        cout << endl;
        return;
    }
    print_postorder(node->left);
    print_postorder(node->right);
    cout << node->name << ", ";
}

void AVLTree::print_level_count() { 
    if (this->root == nullptr) {
        cout << 0 << endl;
        return;
    }
    int level = get_height(this->root);
    cout << level << endl;
}

void AVLTree::remove_inorder(int nth_node) { //slide 19 from discussion 1 ppt on Canvas
    vector<int> inorder_vec;
    inorder_ufid_vector(this->root, inorder_vec);
    int size = inorder_vec.size();
    if (nth_node < 0 || nth_node >= size) {
        cout << "unsuccessful" << endl;
        return;
    }
    int ufid_to_remove = inorder_vec[nth_node];
    this->root = remove(this->root, ufid_to_remove);
}

void AVLTree::inorder_ufid_vector(Node* node, vector<int>& inorder_vec) {
    if (node == nullptr) {
        return;
    }
    inorder_ufid_vector(node->left, inorder_vec);
    inorder_vec.push_back(node->ufid);
    inorder_ufid_vector(node->right, inorder_vec);
}

int AVLTree::get_height(Node* node) {
        if (node == nullptr) return 0;
        return node->height;
    }

int AVLTree::get_balance(Node* node) {
    if (node == nullptr) return 0;
    return get_height(node->left) - get_height(node->right); //formula from project 1 ppt slides
}

AVLTree::~AVLTree() {
    remove_flag = true; //copilot suggested i include a flag after "unsuccessful" was being printed during destructor call
    Node* node = this->root;
    if (node == nullptr) {
        remove_flag = false; 
        return;
    }
    remove(node->left, node->ufid);
    remove(node->right, node->ufid);
    remove_flag = false;
}